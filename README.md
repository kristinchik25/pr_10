# pr_10
## Практическая работа 10. Аналитика с использованием сложных типов данных. Поиск и анализ продаж
## Цель:
Создать эффективную внутреннюю поисковую систему для отдела продаж, позволяющую быстро находить клиентов по контактной информации и истории приобретённых ими продуктов, с использованием сложных типов данных для анализа продаж и улучшения клиентского взаимодействия.

## Задачи:
1. Используя таблицу customer_sales, создайте доступное для поиска представление с одной записью для каждого клиента. Это представление
должно быть отключено от столбца customer_id и доступно для поиска по всей базе данных, что связано с этим клиентом:
• имя,
• адрес электронной почты,
• телефон,
• приобретенные продукты.
2. Создайте доступный для поиска индекс, созданного вами ранее
представления.
3. У кулера с водой продавец спрашивает, можете ли вы использовать свой новый поисковый прототип, чтобы найти покупателя по имени Дэнни, купившего скутер Bat. Запросите новое представление с возможностью поиска, используя ключевые слова «Danny Bat». Какое количество строк вы получили?
4. Отдел продаж хочет знать, насколько часто люди покупают скутер и
автомобиль. Выполните перекрестное соединение таблицы продуктов с самой собой, чтобы получить все отдельные пары продуктов и удалить одинаковые пары (например, если название продукта совпадает). Для каждой пары выполните поиск в представлении, чтобы узнать, сколько клиентов соответствует обоим продуктам в паре. Можно предположить, что выпуски ограниченной серии можно сгруппировать вместе с их аналогом стандартной модели (например, Bat и Bat Limited Edition можно считать одним и тем же скутером

## Выполнение практической работы
Будем выполнять данную работу в своей БД в Pd Admin с заранее загруженными данными в нее

## Задание 1. Используя таблицу customer_sales, создайте доступное для поиска представление с одной записью для каждого клиента. Это представление должно быть отключено от столбца customer_id и доступно для поиска по всей базе данных, что связано с этим клиентом: имя, адрес электронной почты, телефон, приобретенные продукты.

````
CREATE MATERIALIZED VIEW customer_search AS (
SELECT
customer_json -> 'customer_id' AS customer_id, 
customer_json,to_tsvector('english', customer_json) AS search_vector
FROM customer_sales
);
````
## Задание 2. Создайте доступный для поиска индекс, созданного вами ранее представления.
````
CREATE INDEX customer_search_gin_idx ON customer_search USING GIN(search_vector);
````

## Задание 3. Запросите новое представление с возможностью поиска, используя ключевые слова «Danny Bat». Какое количество строк вы получили?
````
SELECT
customer_id,
customer_json
FROM customer_search
WHERE search_vector @@ plainto_tsquery('english', 'Danny Bat');
````
## Результат
![image](https://github.com/user-attachments/assets/89a55612-4b90-4e37-af8d-9204bb0e26f8)

Мы получили 8 строк

## Задание 4. Выполните перекрестное соединение таблицы продуктов с самой собой, чтобы получить все отдельные пары продуктов и удалить одинаковые пары (например, если название продукта совпадает). Для каждой пары выполните поиск в представлении, чтобы узнать, сколько клиентов соответствует обоим продуктам в паре. Можно предположить, что выпуски ограниченной серии можно сгруппировать вместе с их аналогом стандартной модели (например, Bat и Bat Limited Edition можно считать одним и тем же скутером
````
SELECT DISTINCT
p1.model,
p2.model
FROM products p1
LEFT JOIN products p2 ON TRUE
WHERE p1.product_type = 'scooter'
AND p2.product_type = 'automobile'
AND p1.model NOT ILIKE '%Limited
Edition%';
````

## Результат

![image](https://github.com/user-attachments/assets/30f371ba-03f4-414b-a60b-8302eff86f09)

## Задание 5. Преобразовываем вывод в запрос.
````
SELECT DISTINCT
plainto_tsquery('english', p1.model) &&
plainto_tsquery('english', p2.model)
FROM products p1
LEFT JOIN products p2 ON TRUE
WHERE p1.product_type = 'scooter'
AND p2.product_type = 'automobile'
AND p1.model NOT ILIKE '%Limited Edition%';
````
## Результат

![image](https://github.com/user-attachments/assets/7964e713-7d3f-40a0-a854-198994f8d68d)


## Задание 6.  Делаем запрос базы данных, используя каждый из объектов tsquery, и подсчитываем вхождения для каждого объекта.
````
SELECT
sub.query,
	(
		SELECT COUNT(1)
		FROM customer_search
		WHERE customer_search.search_vector @@ sub.query)
FROM (
	SELECT DISTINCT
		plainto_tsquery('english', p1.model) &&
		plainto_tsquery('english', p2.model) AS query
	FROM products p1
	LEFT JOIN products p2 ON TRUE
	WHERE p1.product_type = 'scooter'
	AND p2.product_type = 'automobile'
	AND p1.model NOT ILIKE '%Limited Edition%'
	) sub
ORDER BY 2 DESC;
````

## Результат
![image](https://github.com/user-attachments/assets/7c80f382-536f-42f7-ba39-15f15ea3e062)

 ## Выводы
В процессе реализации эффективной внутренней поисковой системы на основе сложных типов данных,мы помогли отделу продаж оперативно находить нужных клиентов по контактным данным и истории покупок. Это значительно ускоряет рабочие процессы, повышает точность анализа продаж и улучшает качество взаимодействия с клиентами за счёт удобного и структурированного доступа к информации. Такая система становится важным инструментом для поддержки маркетинговых и коммерческих решений внутри компании.
